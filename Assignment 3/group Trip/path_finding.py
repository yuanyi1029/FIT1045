import city_country_csv_reader
from locations import City, Country
from trip import Trip
from vehicles import Vehicle, create_example_vehicles
import networkx
import math


def find_shortest_path(vehicle: Vehicle, from_city: City, to_city: City) -> Trip:
    """
    Returns a shortest path between two cities for a given vehicle,
    or None if there is no path.

    Arguments:
        -vehicle: Vehicle object used to determine shortest path between two cities
        -from_city: Departing City object
        -to_city: Arriving City object
    """
    if vehicle.__class__.__name__ == "CrappyCrepeCar":
        shortest_path = Trip(from_city)
        shortest_path.add_next_city(to_city)

        return shortest_path

    # Since CrappyCrepeCar may travel between any two cities at a set speed, the direct route between the two cities
    # is always the shortest route.

    else:
        path = networkx.Graph()

        if vehicle.__class__.__name__ == "DiplomacyDonutDinghy":
            for city in City.cities.values():
                if city.country == from_city.country or city.country == to_city.country:
                    path.add_node(city)

        else:
            for city in City.cities.values():
                path.add_node(city)

        # A graph is created and nodes representing the related cities are added for the vehicles
        # TeleportingTarteTrolley and DiplomacyDonutDinghy. Only cities that are the same as the from_city or to_city
        # are added as nodes when the DiplomacyDonutDinghy vehicle is used to speed up the execution of the code
        # because it can go between any two cities within the same nation but can only move from one country to
        # another via their capitals. All cities, regardless of country, are included as nodes for the
        # TeleportingTarteTrolley vehicle since it may teleport between any two cities as long as they are within its
        # maximum travel distance.

        for city in path.nodes():
            for other_city in path.nodes():
                path.add_edge(city, other_city, weight=vehicle.compute_travel_time(city, other_city))

        # Every city node is connected to every other city node by an edge that holds the weight of the vehicle's
        # travel time between the two cities.

        shortest_path_list = networkx.dijkstra_path(path, from_city, to_city)

        if vehicle.compute_travel_time(from_city, shortest_path_list[1]) != math.inf:
            shortest_path = Trip(from_city)

            for city in shortest_path_list[1:]:
                shortest_path.add_next_city(city)

            return shortest_path

        # A list representing the shortest path is produced using the Dijkstra's algorithm. The return value will be
        # None if the first two elements in the list compute a trip time of math.inf (there is no path between
        # from_city and to_city). Otherwise, the code will use the list generated by the Dijkstra's algorithm to
        # return the shortest path.


if __name__ == "__main__":
    city_country_csv_reader.create_cities_countries_from_CSV("worldcities_truncated.csv")

    vehicles = create_example_vehicles()

    australia = Country.countries["Australia"]
    melbourne = australia.get_city("Melbourne")
    japan = Country.countries["Japan"]
    tokyo = japan.get_city("Tokyo")

    for vehicle in vehicles:
        print("The shortest path for {} from {} to {} is {}".format(vehicle, melbourne, tokyo, find_shortest_path(vehicle, melbourne, tokyo)))
